# -*- coding: utf-8 -*-
"""girvan-newman.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wDBIYLozesToYCaAyEotwyKn7agzqPGn
"""

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import sys
from collections import deque, Counter

def shortest_paths(graph, start):
  """ Get all distances from the 'start' node and its path to all nodes in the graph 

      Returns:
          distances: dict(node, shortest_distance_from_start),
          parents: path from node to start as dict(node,predecessor),
          num_shortest_paths: dict(node, num_shortest_paths_from_start)
  """
  #visited list to avoid loops
  visited= []

  #distances from each node to the 'start' node
  distances = dict ( [(node, sys.maxsize) for node in graph.nodes()] ) 

  #predecessors from each node to the 'start' node 
  parents =  dict ( [(node, []) for node in graph.nodes()] )

  #number of shortest paths
  num_shortest_paths = dict ( [(node, []) for node in graph.nodes()] )

  #initialize before loop
  distances[start] = 0
  parents[start] = None
  num_shortest_paths[start] = 1

  #queue data structure for BFS
  queue = deque()
  queue.append(start)

  #mark 'start' as visited
  visited.append(start)

  while (len(queue) != 0):
    visiting = queue.popleft() #visit the first element of the queue (remove it)
    visited.append(visiting) #mark as visited

    for adj in graph.adj[visiting]: #iterate through adjacent nodes
      if (adj not in visited) and (adj not in queue):
        queue.append(adj) #add not visited nodes to queue

      #if 'adj' node has been visited before and has a longer path that using '
      #visiting' as predecessor --> update it (this is the shortest path)

      #if 'adj' node has not been visited before, it will always enter this 'if'
      #because distances are initialized as sys.maxsize
      if (distances[adj] > distances[visiting] + 1): 
        distances[adj] = distances[visiting] + 1
        parents[adj].clear()
        parents[adj].append(visiting)
        num_shortest_paths[adj] = num_shortest_paths[visiting]


      #if 'adj' node has the same distance than 'visiting' + 1, it means we have
      #encountered another shortest path --> add 'visiting' as parent in 
      #the shortest path
      elif (distances[adj] == distances[visiting] + 1):
        parents[adj].append(visiting)
        num_shortest_paths[adj] += num_shortest_paths[visiting]

  #End of algorithm, return results
  return distances, parents, num_shortest_paths

# ### Test code
# distances, parents, num_shortest_paths = shortest_paths(graph, 'CAPTAIN AMERICA')
# distances

def get_edge_betweenness(graph, start):
  """
  Get edge betweenness of all edges given source node 'start' 
  """

  edges_btwnss = dict([(edge, 0) for edge in graph.edges()])
  node_betweenness = dict([(node, 0) for node in graph.nodes()])
  
  distances, parents, num_shortest_paths = shortest_paths(graph, start) 

  #furthest nodes from the selected node
  furthest_nodes = sorted(distances, key=distances.get, reverse=True)

  for node in furthest_nodes:
    if node != start:
      for parent in parents[node]:
        node_betweenness[parent] += (1 + node_betweenness[parent]) / len(parents[node])
        if (node, parent) in edges_btwnss:
          edges_btwnss[node,parent] = (1 + node_betweenness[node]) / num_shortest_paths[node]
        elif (parent,node) in edges_btwnss:
          edges_btwnss[parent,node] = (1 + node_betweenness[node]) / num_shortest_paths[node]

  return edges_btwnss

def edge_betweenness(graph):

  btwnss = [0] * len(graph.edges())

  for node in graph.nodes():
    btwnnss_node = get_edge_betweenness(graph, node)
    btwnss = np.add(btwnss, list(btwnnss_node.values())) #here we are using a dict_view instead of original values
    
  #since dict_view has 15 significant ciphers, we will be using 14
  btwnss = [round(score, 14) for score in btwnss]
  btwnss_dict = dict(zip(graph.edges(), btwnss))
  
  return btwnss_dict

def Girvan_Newman(graph, k):

  g = graph.copy()

  if (k == 0):
    return g

  for iterations in np.arange(k):
    betweenness = edge_betweenness(g)
    betweenness_values = list(betweenness.values())

    edges_sorted = sorted(betweenness, key=betweenness.get, reverse=True)
    betweenness_values_sorted = sorted(betweenness_values, reverse=True)

    value= betweenness_values_sorted.pop(0)
    edge = edges_sorted.pop(0)

    g.remove_edge(edge[0],edge[1])

  return g

def Girvan_Newman2(graph):

  g = graph.copy()
  k = graph.number_of_edges()
  graphs = []

  for iterations in np.arange(k):
    betweenness = edge_betweenness(g)
    betweenness_values = list(betweenness.values())

    edges_sorted = sorted(betweenness, key=betweenness.get, reverse=True)
    betweenness_values_sorted = sorted(betweenness_values, reverse=True)

    value= betweenness_values_sorted.pop(0)
    edge = edges_sorted.pop(0)

    g.remove_edge(edge[0],edge[1])

    graphs.append(g.copy())

  return graphs
# ###Test Code
# g = Girvan_Newman2(graph)

def Girvan_Newman_dendrogram(graph):
  """
  Returns a dendrogram corresponding with the result of the Girvan-Newman method.
  """
  graphs = Girvan_Newman2(graph)
  dendrogram = []
  for g in graphs:
    dendrogram.append([list(g.subgraph(c).nodes()) for c in nx.connected_components(g)])
  
  return dendrogram

# #Test 
# dd = Girvan_Newman_dendrogram(karate)
# print(dd)
# nx.algorithms.community.quality.modularity(karate, dd[10])

def Girvan_Newman_2004(graph):
  """
  Girvan Newman method proposed in Finding and evaluating community structure in networks
  by M. E. J. Newman and M. Girvan in 2004.
  """
  g = graph.copy()
  k = graph.number_of_edges()
  dendrogram = []

  for iterations in np.arange(k):
    betweenness = edge_betweenness(g)
    betweenness_values = list(betweenness.values())

    edges_sorted = sorted(betweenness, key=betweenness.get, reverse=True)
    betweenness_values_sorted = sorted(betweenness_values, reverse=True)

    value= betweenness_values_sorted.pop(0)
    edge = edges_sorted.pop(0)

    g.remove_edge(edge[0],edge[1])

    #Append dendrogram with connected components
    dendrogram.append([list(g.subgraph(c).nodes()) for c in nx.connected_components(g.copy())])

  
  #Select partition with best modularity
  mod_new = 0 
  mod = 0
  threshold = True
  i = 0
  best_mod = 0
  best_partition = None


  for partition in dendrogram:
    mod_new = nx.algorithms.community.quality.modularity(graph, partition)
    if (mod_new > best_mod):
      best_partition = partition
      best_mod = mod_new
    mod = mod_new
  
  return best_partition, best_mod

def dendrogram_to_community(dendrogram):
  """
  Converts a dendrogram to a community dict
  Returns: dict({node:community_name})
  """
  community = dict()
  community_num = 0
  for comp in dendrogram:
    for node in comp:
      community.update({node:community_num})
    community_num += 1
  return community

def draw_communities(graph, community):
  """ Draws the graph using colors as community identifier
  """
  pos = nx.spring_layout(graph)
  cmap = cm.get_cmap('viridis', max(community.values()) + 1)
  nx.draw_networkx_nodes(graph, pos, community.keys(), node_size=40,
                        cmap=cmap, node_color=list(community.values()))
  nx.draw_networkx_edges(graph, pos, alpha=0.5)
  plt.show()

def draw_communities_fixed_pos(graph, community, pos):
  """ 
  Draws the graph using colors as community identifier using given pos
  """
  cmap = cm.get_cmap('viridis', max(community.values()) + 1)
  nx.draw_networkx_nodes(graph, pos, community.keys(), node_size=40,
                        cmap=cmap, node_color=list(community.values()))
  nx.draw_networkx_edges(graph, pos, alpha=0.5)
  plt.show()