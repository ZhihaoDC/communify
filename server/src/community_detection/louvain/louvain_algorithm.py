# -*- coding: utf-8 -*-
"""louvain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MaMroSuGpTTax6-WIyHrxCsb1qy3rlyI
"""

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from random import shuffle

def modularity(graph, m, community, k):
  """
  Computes modularity of a partition where:
  'graph' = networkx.Graph()
  'm' = sum of all the weights of edges in the graph
  'community' = dict of the node communities like: dict({node:community_name})
  'k' = dict of the node degrees like: dict({node:degree_node})
  """
  m = (1/2) * m
  modularity = 0 
  for i in graph.nodes():
    if i not in k:
        k.update({i: graph.degree(i, 'weight')})
    ki = k[i]
    for j in graph.nodes():
      if (i != j) and (community[i] == community[j]):
        data = graph.get_edge_data(i,j,default= 0)
        if (data != 0):
          A_ij = data['weight']/2
          if j not in k:
            k.update({j: graph.degree(j, 'weight')})
          kj = k[j]

          modularity += A_ij - (ki * kj) / (2*m)

  modularity = modularity / (2*m)
  # print(modularity, '||', nx.algorithms.community.quality.modularity(graph,dendrogram(community)))
  return modularity

def rename(community):
  """ 
  Renumbers community identifier to lowest range of values possible
  """
  set_values = set(community.values())
  renumbered_values = set(range(len(set_values)))
  renumbered = dict(zip(set_values,renumbered_values))

  transformed = {key:renumbered[value] for key,value in community.items()}

  return transformed

# #Test Code
# my_community = {1:11, 2:22, 3:22, 4:22, 5:4, 6:4, 7:11}
# my_set = set(my_community.values())
# my_set_new = set(range(len(my_set)))

# my_dict = dict(zip(my_set, my_set_new))

# transformed = { key:my_dict[value] for key,value in my_community.items()}



def sum_tot(graph, community, community_name):
  nodes_C = [node for node, com in community.items() if com == community_name] #nodes in community C
  edges_C = graph.edges(nodes_C, data=True)
  sum_tot = 0

  for u,v,data in edges_C:
    weight = data['weight']
    sum_tot += weight

  return sum_tot

def ki_in(graph, community, selected, community_name):
  nodes_C = [node for node, com in community.items() if com == community_name] #nodes in community C
  incident_i = graph.edges(selected, data=True)
  ki_in = 0

  for u,v,data in incident_i:
    weight = data['weight']

    if ((u in nodes_C) and (v == selected)) or ((v in nodes_C) and (u == selected)):
      ki_in += weight

  return ki_in

def first_step(graph, m, community):
  """
  Computes one level of communities in Louvain's algorithm
  Returns: dict of node communities, like: dict({node:community_name})
  """
  bestmod_inc = 0
  # removing_cost = dict() #cost of removing each node from its community
  nodes_community = dict(list()) #dictionary of communities and the nodes they contain
  sum_tot_community = dict() #dict of sum_tot of communities
  ki_in_community = dict() #dict of ki_in from node to communities
  k = dict()

  new_mod = modularity(graph, m, community,k)
  threshold = True
  while threshold:
    mod = new_mod
    nodes = list(graph.nodes())
    shuffle(nodes)
    for node in nodes:

      # Check mod_inc
      # print('----------------------------------')
      bestmod_inc = 0
      if node not in k:
        k.update({node: graph.degree(node, 'weight')})
      if community[node] not in sum_tot_community:
        sum_tot_community.update({community[node]: sum_tot(graph, community, community[node])}) #compute sum_tot for community
      if community[node] not in ki_in_community:
        ki_in_community.update({community[node]: ki_in(graph, community, node, community[node])})

      removing_cost = - (ki_in_community[community[node]] - (sum_tot_community[community[node]] * k[node]/(2*m)))

        
      adj_nodes = list(graph.adj[node])
      shuffle(adj_nodes)
      for adj in adj_nodes:
        if community[node] != community[adj]:
          if adj not in k:
            k.update({adj:graph.degree(adj, 'weight')})
          if community[adj] not in sum_tot_community:
            sum_tot_community.update({community[adj]: sum_tot(graph, community, community[adj])}) #compute sum_tot for community
          if community[adj] not in ki_in_community:
            ki_in_community.update({community[adj]: ki_in(graph, community, node, community[adj])})

          mod_inc = ki_in_community[community[adj]] - (sum_tot_community[community[adj]] * k[node]/(2*m))
          
          mod_inc += removing_cost
          # Check mod_inc
          # print('------------', mod_inc, bestmod_inc)
          if mod_inc > bestmod_inc:
            
            bestmod_inc = mod_inc
            
            sum_tot_community.pop(community[node], -1)
            ki_in_community.pop(community[node], -1)

            sum_tot_community.pop(community[adj], -1)
            ki_in_community.pop(community[adj], -1)

            best_com = community[adj]
            community[node] = best_com #move node to best_com


      ki_in_community.clear()
    new_mod = modularity(graph, m, community,k)
    # print(new_mod,'>', mod,'?')
    threshold = ((new_mod - mod) > 0.0000001)
    # print(threshold)
  community = rename(community)
  return community

def draw_communities(graph, community):
  """ 
  Draws the graph using colors as community identifier
  """
  pos = nx.spring_layout(graph)
  cmap = cm.get_cmap('viridis', max(community.values()) + 1)
  nx.draw_networkx_nodes(graph, pos, community.keys(), node_size=40,
                        cmap=cmap, node_color=list(community.values()))
  nx.draw_networkx_edges(graph, pos, alpha=0.5)
  plt.show()

def draw_communities_fixed_pos(graph, community, pos):
  """ 
  Draws the graph using colors as community identifier using given pos
  """
  cmap = cm.get_cmap('viridis', max(community.values()) + 1)
  nx.draw_networkx_nodes(graph, pos, community.keys(), node_size=40,
                        cmap=cmap, node_color=list(community.values()))
  nx.draw_networkx_edges(graph, pos, alpha=0.5)
  plt.show()

def dendrogram(community):
  """
  Returns a list of lists where each sublist is a community
  Returns: list(list())
  """
  values = set(list(community.values()))
  dendrogram = []
  for com in values:
    dendrogram.append([key for key,value in community.items() if value == com])
  return dendrogram

def merge_communities(graph, community):
  """
  Merges communities in community to form a new graph
  Returns: networkx.Graph()
  """
  values = set(community.values())
  new_graph = nx.Graph()
  new_graph.add_nodes_from(values)

  for u, v, data in graph.edges(data=True):
    com1 = community[u]
    com2 = community[v]
    old_weight = new_graph.get_edge_data(com1, com2, default= {'weight' : 0})
    # print(old_weight, data['weight'])
    new_graph.add_edge(com1, com2, weight= old_weight['weight'] + data['weight'])
    # new_graph.add_edge(com1, com2, **{'weight': old_weight + data['weight']})

  return new_graph

def draw_merged_communities(graph):
  pos = nx.spring_layout(graph)
  cmap = cm.get_cmap('viridis', graph.number_of_nodes())
  nx.draw_networkx_nodes(graph, pos, node_size=500,
                          cmap=cmap, node_color=graph.nodes())
  
  nx.draw_networkx_edges(graph, pos, alpha=0.5)

  labels = nx.get_edge_attributes(graph,'weight')
  nx.draw_networkx_edge_labels(graph, pos, labels)

  x_values, y_values = zip(*pos.values())
  x_max = max(x_values)
  x_min = min(x_values)
  x_margin = (x_max - x_min) * 0.1
  y_max = max(y_values)
  y_min = min(y_values)
  y_margin = (y_max - y_min) * 0.1

  plt.xlim(x_min - x_margin, x_max + x_margin)
  plt.ylim(y_min - y_margin, y_max + y_margin)
  plt.show()
  plt.show()

def Louvain(graph):
  """ 
  Detects community in graph using Louvain's algorithm
  """
  communities = []

  graph = graph.copy()

  if not nx.get_edge_attributes(graph, "weight"):
    nx.set_edge_attributes(graph, 1, name='weight')

  n = graph.number_of_nodes()
  m = graph.size('weight')
  community = dict(zip(graph.nodes(), np.arange(n))) #Assign every node to a different community   
  community = first_step(graph, m, community)
  
  k = dict()

  mod_new = modularity(graph, m, community,k)
  mod = mod_new
  communities.append(community)

  # print('First merge')
  graph_new = merge_communities(graph,community)

  while True:
    n = graph_new.number_of_nodes()
    m = graph_new.size('weight')
    community = dict(zip(graph_new.nodes(), np.arange(n))) #Assign every node to a different community  
    # print('first step')
    community = first_step(graph_new, m, community)
    # print('first step done')
    mod_new = modularity(graph_new, m, community,k)
    # print(community)
    # print('Comparing:', mod_new, mod, 'diff < 0.0000001????')
    if mod_new - mod < 0.0000001:
      # print('Exit')
      break
    
    mod = mod_new
    communities.append(community)
    # print('One more merge')
    graph_new = merge_communities(graph_new, community)

  return (graph_new, communities)

def last_community(graph, communities):
  summary = communities[0]
  for index in np.arange(1,len(communities)):
    for node, com in summary.items():
      summary[node] = communities[index][com]

  return summary